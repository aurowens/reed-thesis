---
title: "Sampling"
author: "Aurora Owens"
date: "November 1st, 2016"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
    highlight: kate
    theme: spacelab
---


## Setup

```{r loadlib, warning=FALSE, message=FALSE}
library(MASS)
library(ggplot2)
library(dplyr)
library(tree)
library(randomForest)
library(maptree)
library(gridExtra)
```


```{r function}
intervalReturn <- function(split.cutleft){ 
  intervals <- data.frame(split.cutleft)
  intervals <- filter(intervals, split.cutleft != "")
  intervals <- dplyr::select(intervals, split.cutleft)
  intervals$split.cutleft <- gsub("<", "", intervals$split.cutleft)
  intervals$split.cutleft <- as.numeric(intervals$split.cutleft)
  return(arrange(intervals, (split.cutleft)))
}

partitionCreator <- function(i = interval, x, data) {
  p <- c(1:(1+nrow(i)))
  bins <- data.frame (bin = rep(1, nrow(data)), x = data[,x])
  for(j in 1:nrow(i)){
    bins[bins$x > i[j,1],1] <- p[j+ 1]
  }
  return(bins$bin)
}

condPermuter <- function(d2, x) {
  d2$p <- as.factor(d2$p)
  for(i in 1:length(levels(d2$p))){
   #set.seed(1)
   d2[d2$p == i, x] <- sample(d2[d2$p== i,x])
  }
  return(d2[,x])
}

tree.error <- function(tree) {  #This function was added 
  yhat <- predict(tree)
  return(sum(abs(tree$y - yhat)))
}

variable.importance <- function(formula1, x, d){
  t1 <- tree(formula1, data = d, y = TRUE) #This is the biggest change from CVIM_one_tree. I added this function variable.importance() to serve as a wrapper for the other functions and I created a new tree with new partitions at each interation
  #e0 <- tree.error(t1,y)
  interval <- intervalReturn(t1$frame$splits[,1])
  #permed <- data
  d$p <- partitionCreator(interval, x, d)
  d[,x] <- condPermuter(d, x)
  t2 <- tree(y ~ ., data = d, y = TRUE)
  e1 <- tree.error(t2)
  #rm(t1, t2)
  return(e1)
}
```

#Using the sampling scheme from Strobl et al, see `literature-review`

#### Simulation

Using `mvrnorm` from the MASS package:

```{r}
rep(0, 12) -> mu #mean of each variable

diag(12) -> sigma #creates a 12 by 12 diagonal matrix with 1's down the diagonal
```

Long, messy way to define $\Sigma$
```{r}
sigma -> sigma1
.9 -> sigma1[1,2]
.9 -> sigma1[2,1] #adding the block correlation between the first four variables
.9 -> sigma1[1,3]
.9 -> sigma1[3,1]
.9 -> sigma1[3,2]
.9 -> sigma1[2,3]
.9 -> sigma1[1,4]
.9 -> sigma1[4,1]
.9 -> sigma1[2,4]
.9 -> sigma1[4,2]
.9 -> sigma1[4,3]
.9 -> sigma1[3,4]

sigma1
```

Sampling
```{r}
1000 -> n
set.seed(1)
mvrnorm(n =n, mu = mu, Sigma = sigma1) -> sim1000 
```

Getting the ys
```{r}
c(5,5,2,0,-5,-5,-2,0,0,0,0,0) -> bts #these are the betas 

rnorm(1000, mean = 0, sd = .5) -> e #error terms

rep(0, 1000) -> ys #init a vector of zeros

for( i in 1:1000){ #go row by row and create the ys based on the function of e, bts, and sim1000
ys[i] <- sim1000[i,1]*bts[1]+
    sim1000[i,2]*bts[2]+ 
    sim1000[i,3]*bts[3]+ 
    sim1000[i,4]*bts[4]+ 
    sim1000[i,5]*bts[5]+ 
    sim1000[i,6]*bts[6]+
    sim1000[i,7]*bts[7]+ 
    sim1000[i,8]*bts[8]+ 
    sim1000[i,9]*bts[9]+ 
    sim1000[i,10]*bts[10]+ 
    sim1000[i,11]*bts[11]+ 
    sim1000[i,12]*bts[12] +
    e[i]
}

mvn.data <- as.data.frame(sim1000)
mvn.data$y <- ys
```

#### A tree based on `mvn.data`

```{r}
t1 <- tree(y ~., data = mvn.data)

plot(t1)
text(t1)
 
tree.error(t1)
```

#### Distribution of Variable Importance for V1 and V2

```{r}
v1vi <- rep(0,50)
v2vi <- rep(0,50)
v3vi <- rep(0,50)
v4vi <- rep(0,50)


d = mvn.data
set.seed(1)
for (i in 1:50){
v1vi[i] <- variable.importance(V1~., "V1", d = mvn.data)
#d <- select(mvn.data, -p)
}

qplot(v1vi, main = "Distribution of Tree Error when V1 is Permuted wrt All Other Variables",geom = "histogram")

set.seed(1)
for(i in 1:500){
v2vi[i] <- variable.importance(V2~., "V2",  d=  mvn.data)
}

qplot(v2vi, main = "Distribution of Tree Error when V2 is Permuted wrt All Other Variables", geom = "histogram")

```
