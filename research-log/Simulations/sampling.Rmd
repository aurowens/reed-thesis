---
title: "Sampling"
author: "Aurora Owens"
date: "November 1st, 2016"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
    highlight: kate
    theme: spacelab
---

This isn't going terribly well. I reworked some of the functions from `CVIM_one_tree` but there are still instances where constant values are being returned. See `variability_of_trees.Rmd` for more.  


## Setup

```{r loadlib, warning=FALSE, message=FALSE}
library(ggplot2)
library(dplyr)
library(tree)
library(randomForest)
library(maptree)
library(gridExtra)
```


```{r function}
intervalReturn <- function(split.cutleft){ 
  intervals <- data.frame(split.cutleft)
  intervals <- filter(intervals, split.cutleft != "")
  intervals <- select(intervals, split.cutleft)
  intervals$split.cutleft <- gsub("<", "", intervals$split.cutleft)
  intervals$split.cutleft <- as.numeric(intervals$split.cutleft)
  return(arrange(intervals, (split.cutleft)))
}

partitionCreator <- function(i = interval, x, data) {
  p <- c(1:(1+nrow(i)))
  bins <- data.frame (bin = rep(1, nrow(data)), x = data[,x])
  for(j in 1:nrow(i)){
    bins[bins$x > i[j,1],1] <- p[j+ 1]
  }
  return(bins$bin)
}

condPermuter <- function(d2, x) {
  d2$p <- as.factor(d2$p)
  for(i in 1:length(levels(d2$p))){
   #set.seed(1)
   d2[d2$p == i, x] <- sample(d2[d2$p== i,x])
  }
  return(d2[,x])
}

tree.error <- function(tree) {  #This function was added 
  yhat <- predict(tree)
  return(sum(abs(tree$y - yhat)))
}

variable.importance <- function(formula1, x, data){
  t1 <- tree(formula1, data, y = TRUE) #This is the biggest change from CVIM_one_tree. I added this function variable.importance() to serve as a wrapper for the other functions and I created a new tree with new partitions at each interation
  #e0 <- tree.error(t1,y)
  interval <- intervalReturn(t1$frame$splits[,1])
  #permed <- data
  data$p <- partitionCreator(interval, x, data)
  data[,x] <- condPermuter(data, x)
  t2 <- tree(y ~ x1 + x2, data, y = TRUE)
  e1 <- tree.error(t2)
  #rm(t1, t2)
  return(e1)
}
```

## linearly related functional forms 

### Simulating the data 
```{r}

set.seed(1)

x1 <- rnorm(5000) #maybe generate from the uniform

set.seed(2)

x2 <- 3* x1 +rnorm(5000)


set.seed(3)

y <- 5*x1 + 4*x2 + rnorm(5000) 

data <- data.frame(y,x1,x2)
```

### The distribution of conditionally-permuted variable importance

```{r}
set.seed(1)

t0 <- tree(y ~ x1 + x2, data, y = TRUE)
e0 <- tree.error(t0)

#x1vi has a very peaked distribution, even with a relatively small sample size

x1vi <- rep(0,50)
x2vi <- rep(0,50)

set.seed(1)
for (i in 1:500){
x1vi[i] <- variable.importance(x1~x2, "x1", data)
}

set.seed(1)
for(i in 1:500){
x2vi[i] <- variable.importance(x2~x1, "x2", data)
}

plot(x1vi)
plot(x2vi)

hist(x1vi)
p <- ggplot(as.data.frame(x1vi)) + geom_histogram(aes(x = x1vi), binwidth = 100) + geom_vline(xintercept  = e0, color = "red")
q <- ggplot(as.data.frame(x2vi)) + geom_histogram(aes(x = x2vi)) +  geom_vline(xintercept  = e0, color = "red")

grid.arrange(p,q)
```



## sampling from the uniform distribution

```{r}
x1 <- runif(1000)

x2 <- 2*x1 + rnorm(1000)

y <- 4*x1 + 5* x2 + rnorm(1000)

sim2 <- data.frame(y,x1,x2)

set.seed(1)

t0 <- tree(y ~ x1 + x2, sim2)
e0 <- tree.error(t0)

x1vi <- rep(0,500)
x2vi <- rep(0,500)

set.seed(1) 
for (i in 1:500){
x1vi[i] <- variable.importance(x1~x2, "x1",  sim2)
}

set.seed(1)
for(i in 1:500){
x2vi[i] <- variable.importance(x2~x1, "x2", sim2)
}

plot(x1vi)
plot(x2vi)

plot(x2~x1)

hist(x1vi)
p <- ggplot(as.data.frame(x1vi)) + stat_density(aes(x = x1vi)) + geom_vline(xintercept  = e0, color = "red")
q <- ggplot(as.data.frame(x2vi)) + stat_density(aes(x = x2vi)) +  geom_vline(xintercept  = e0, color = "red")

grid.arrange(p,q)
```

